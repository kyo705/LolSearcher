# Lolsearcher
롤 전적 검색 사이트 프로젝트
=============
-----------------------------------------
롤 전적 검색 사이트란??
-----------------------------------------

롤(League Of Legend) 게임 서버에서 OPEN API로 제공되는 유저의 게임 데이터들(랭킹 점수, 게임 횟수, 상세 게임 정보 등)을 수집하고 가공하여 클라이언트에게 제공하는 사이트입니다.

프로젝트 깃 브런치
-----------------------------------------
> - **main** — 실제 메인 브런치(완성본)
> - **develop** — 다음 버전을 위한 개발 브런치(테스트용)

프로젝트 커밋 메시지 카테고리
-----------------------------------------
> - [INITIAL] — repository를 생성하고 최초에 파일을 업로드 할 때
> - [ADD] — 신규 파일 추가
> - [UPDATE] — 코드 변경이 일어날때
> - [REFACTOR] — 코드를 리팩토링 했을때
> - [FIX] — 잘못된 링크 정보 변경, 필요한 모듈 추가 및 삭제
> - [REMOVE] — 파일 제거
> - [STYLE] — 디자인 관련 변경사항


프로젝트 내 적용 기술
-----------------------------------------
> - 백 앤드
>   - 언어 : Java
>   - 프레임 워크 : SpringBoot, Spring MVC, Spring Security
>   - 빌드 관리 툴 : Gradle
>   - 스케줄러 : Spring Quartz
>   - REST API 수집 : WebClient
>   - ORM : JPA(Hibernate)
> - DevOps
>   - Message Queue : Kafka
>   - DBMS :
>      - 실제 서버 환경 : MariaDB
>      - 테스트 환경 : h2
> - 프론트 앤드
>   - 템플릿 엔진 : Thymeleaf

프로젝트 서버 구조
-----------------------------------------
![image](https://user-images.githubusercontent.com/89891704/200253517-5f6c3b3a-2d67-4664-9d62-da4c920cb200.png)

프로젝트 톰캣 스레드풀 최소 갯수 설정
-------------------------
**커넥션풀 사이즈 공식 : 스레드 수 = 사용 가능한 코어 수 * (1+대기 시간/서비스 시간)**   
[by  "Java Concurrency in Practice"]   

위 공식을 적용하여 성능 측정 결과 최소 36, 최대 72의 스레드 갯수가 나오므로 최소 유지 스레드 갯수를 평균값인 54로 적용함

프로젝트 HikariCP 커넥션풀 최소 갯수 설정
-------------------------
**커넥션풀 사이즈 공식 : connections = ((core_count * 2) + effective_spindle_count)   
[by https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing]**

로컬 CPU 6 core 12 thread, 하드디스크 1개이므로 커넥션풀 사이즈 25로 설정

테스트 코드 설명서
--------------------------
테스트 환경 프레임 워크 : springboot, mockito, junit5   

 해당 프로젝트의 테스트 코드는 비지니스 로직을 중점으로 크게 두가지(단위 테스트, 통합 테스트)로 작성되었다.   
   
- 단위 테스트 : Filter, Controller, Service, Repository, RESTClient 계층 별 테스트 실시   
- 통합 테스트 : 해당 단위 테스트 계층들을 실제 서버 위에서 테스트 실시

**※통합 테스트 시 주의점** : REST API 통신 계층도 통합하여 테스트하기 때문에 모든 테스트케이스를 한꺼번에 실행하면 REST API 요청 제한 횟수(2분에 100회)를 초과할 수 있음. 다시 말해, 멱등성이 유지되지 않음.

코드 소스 경로 : lolsearcher/src/test/
 
----------------------------------------

# 프로젝트 과정에서 겪은 고민들과 해결 과정

----------------------------------------

### 게임 서버로부터 요청한 REST API 데이터를 DB에 저장하는 이유

> 1. 성능상 이점 : 클라이언트의 매 요청마다 REST API 요청 시도는 네트워크 I/O 비용이 크기 때문에 비효율적
>
> 2. 통계 데이터 제공 목적 : 유저들의 게임 데이터를 수집해 챔피언별, 아이템별, 승률 제공하기 위함

### 클라이언트가 갱신 요청을 할 경우에만 게임 서버로부터 REST API 요청을 보내도록 설계한 이유 
> 구조적 문제 : 게임 서버에서 제공하는 API는 2분에 100회 요청으로 제한되어있음. 그렇기 때문에 해당 자원을 효율적으로 관리하기 위한 적절한 판단이라 생각함.

### REST API 요청 제한 횟수 어뷰징 공격 상황 및 해결책
> 1. 지나친 갱신 요청을 시도하는 경우 => 갱신 요청 타임스탬프 값을 유저 테이블의 컬럼으로 관리(갱신 요청 시 타임스탬프 값이 5분 이상 경과된 경우에만 갱신 가능)
>
> 2. 존재하지 않는 닉네임을 검색하는 경우 => REST API 응답 코드가 404, 400가 발생한다. 클라이언트 IP를 Key, 실패 요청 횟수를 Value로 하는 Map으로 어뷰징 유저 관리를 하여 특정 횟수 이상되는 경우 IP를 차단하는 로직을 구현 & 스케줄러로 특정 시점 이후 차단 해제


### 클라이언트 체감 성능을 향상시키기 위한 방안

> 1. REST API를 DB에 저장하는 로직과 클라이언트에게 DTO를 전달하는 로직을 분리하여 병렬처리 하도록 설계 (스레드풀을 이용한 멀티스레드 방식)
>
> 2. REST API 요청 시 기존의 불필요한 blocking 처리 방식에서 non-blocking 처리 방식으로 성능 개선   
> ( ※ 멀티 스레드 동기 처리 방식 vs 단일 스레드 비동기 처리 방식)


### REST API로부터 발생한 데이터를 다른 프로세스에서 DB에 저장하도록 설계한 이유

> 1. 데이터 무결성 : 기존 애플리케이션에서 DB에 저장하게 될 때, 톰캣의 멀티스레드 방식이기 때문에 같은 데이터를 동시에 DB에 저장하려는 상황이 발생함. 이 때, 스레드별 배치 처리로 DB에 많은 entity들을 저장하려 한다면 하나의 중복된 entity로 인해 많은 양의 중복되지 않는 entity들도 롤백되는 상황 발생 => 메시지큐에 데이터를 보내 싱글 스레드에서 데이터를 처리하면 해당 상황을 방지할 수 있음
>
> 2. 성능 개선 : 기존 애플리케이션에서 데이터를 한 건씩 DB에 저장하면 동시에 같은 데이터를 저장할 때, 롤백이 발생해도 데이터 무결성을 지킬 수 있음. 하지만 배치 처리를 하지 못하므로 성능이 느림 => 메시지큐로부터 데이터를 받아 배치 처리로 DB에 저장하여 성능을 개선함.


