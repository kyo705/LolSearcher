# LOL SEARCHER

인기 게임 '리그 오브 레전드' 의 게임 전적 데이터를 DB로부터 가져와 클라이언트에게 제공하는 애플리케이션

## 애플리케이션 주요 기능

> 1. 클라이언트가 게임 내 유저의 데이터를 조회 시 Cache, DB로 부터 가져옴
> 2. 차단된 어뷰저가 해당 서비스를 이용하지 못하는 기능 제공
> 3. OPEN API 서비스를 통해 현재 DB에 있는 데이터를 JSON으로 제공
> 4. OPEN API 서비스를 이용하기 위한 회원가입, 로그인 관련 기능들을 제공


프로젝트 깃 브런치
-----------------------------------------
> - **main** — 실제 메인 브런치(완성본)
> - **develop** — 다음 버전을 위한 개발 브런치(테스트용)

프로젝트 커밋 메시지 카테고리
-----------------------------------------
> - [INITIAL] — repository를 생성하고 최초에 파일을 업로드 할 때
> - [ADD] — 신규 파일 추가
> - [UPDATE] — 코드 변경이 일어날때
> - [REFACTOR] — 코드를 리팩토링 했을때
> - [FIX] — 잘못된 링크 정보 변경, 필요한 모듈 추가 및 삭제
> - [REMOVE] — 파일 제거
> - [STYLE] — 디자인 관련 변경사항


프로젝트 내 적용 기술
-----------------------------------------
> - 백 앤드
>   - 언어 : Java
>   - 프레임 워크 : SpringBoot, Spring MVC, Spring Security
>   - ORM : JPA(Hibernate)
>   - 빌드 관리 툴 : Gradle
> - DevOps
>   - WAS : Tomcat
>   - Cache : Redis
>   - DBMS :
>      - 실제 서버 환경 : MariaDB
>      - 테스트 환경 : h2

프로젝트 톰캣 스레드풀 최소 갯수 설정
-------------------------
**커넥션풀 사이즈 공식 : 스레드 수 = 사용 가능한 코어 수 * (1+대기 시간/서비스 시간)**   
[by  "Java Concurrency in Practice"]   

위 공식을 적용하여 성능 측정 결과 최소 36, 최대 72의 스레드 갯수가 나오므로 최소 유지 스레드 갯수를 평균값인 54로 적용함

프로젝트 HikariCP 커넥션풀 최소 갯수 설정
-------------------------
**커넥션풀 사이즈 공식 : connections = ((core_count * 2) + effective_spindle_count)   
[by https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing]**

로컬 CPU 6 core 12 thread, 하드디스크 1개이므로 커넥션풀 사이즈 25로 설정

테스트 코드 설명서
--------------------------
테스트 환경 프레임 워크 : springboot, mockito, junit5   

 해당 프로젝트의 테스트 코드는 비지니스 로직을 중점으로 크게 두가지(단위 테스트, 통합 테스트)로 작성되었다.   
   
- 단위 테스트 : Filter, Controller, Service, Repository, RESTClient 계층 별 테스트 실시   
- 통합 테스트 : 해당 단위 테스트 계층들을 실제 서버 위에서 테스트 실시

**※통합 테스트 시 주의점** : REST API 통신 계층도 통합하여 테스트하기 때문에 모든 테스트케이스를 한꺼번에 실행하면 REST API 요청 제한 횟수(2분에 100회)를 초과할 수 있음. 다시 말해, 멱등성이 유지되지 않음.

코드 소스 경로 : lolsearcher/src/test/
 
----------------------------------------

# 프로젝트 과정에서 겪은 고민들과 해결 과정

----------------------------------------

### 게임 서버로부터 요청한 REST API 데이터를 DB에 저장하는 이유

> 1. 성능상 이점 : 클라이언트의 매 요청마다 REST API 요청 시도는 네트워크 I/O 비용이 크기 때문에 비효율적
>
> 2. 통계 데이터 제공 목적 : 유저들의 게임 데이터를 수집해 챔피언별, 아이템별, 승률 제공하기 위함

### 클라이언트가 갱신 요청을 할 경우에만 게임 서버로부터 REST API 요청을 보내도록 설계한 이유 
> 구조적 문제 : 게임 서버에서 제공하는 API는 2분에 100회 요청으로 제한되어있음. 그렇기 때문에 해당 자원을 효율적으로 관리하기 위한 적절한 판단이라 생각함.

### REST API 요청 제한 횟수 어뷰징 공격 상황 및 해결책
> **문제 상황**   
> 
> 제한된 데이터 수집 상황(2분에 100회 요청 제한)으로 인해 어뷰저가 이를 악용해 빈번하게 REST API 요청 시도를 하는 상황이 발생할 수 있음   
> 
> **해결책** 
> 
> 1. Nginx를 통해 클라이언트의 IP 주소, URI 주소를 기준으로 요청 제한율을 설정   
> 2. Nginx의 동적 캐시 기능을 통해 중복되는 요청을 WAS까지 요청이 들어오지 못하게 설정
> 2. 존재하지 않는 닉네임을 검색하는 등 잘못된 요청을 특정 횟수 이상 시도한 클라이언트 IP 주소를 차단하는 로직 설계


### 클라이언트 체감 성능을 향상시키기 위한 방안

> 1. REST API를 DB에 저장하는 로직과 클라이언트에게 DTO를 전달하는 로직을 분리하여 병렬처리 하도록 설계 (스레드풀을 이용한 멀티스레드 방식)
>
> 2. REST API 요청 시 기존의 불필요한 blocking 처리 방식에서 non-blocking 처리 방식으로 성능 개선   
> ( ※ 멀티 스레드 동기 처리 방식 vs 단일 스레드 비동기 처리 방식)


### REST API로부터 발생한 데이터를 다른 프로세스에서 DB에 저장하도록 설계한 이유

> 1. 데이터 무결성 : 기존 애플리케이션에서 DB에 저장하게 될 때, 톰캣의 멀티스레드 방식이기 때문에 같은 데이터를 동시에 DB에 저장하려는 상황이 발생함. 이 때, 스레드별 배치 처리로 DB에 많은 entity들을 저장하려 한다면 하나의 중복된 entity로 인해 많은 양의 중복되지 않는 entity들도 롤백되는 상황 발생 => 메시지큐에 데이터를 보내 싱글 스레드에서 데이터를 처리하면 해당 상황을 방지할 수 있음
>
> 2. 성능 개선 : 기존 애플리케이션에서 데이터를 한 건씩 DB에 저장하면 동시에 같은 데이터를 저장할 때, 롤백이 발생해도 데이터 무결성을 지킬 수 있음. 하지만 배치 처리를 하지 못하므로 성능이 느림 => 메시지큐로부터 데이터를 받아 배치 처리로 DB에 저장하여 성능을 개선함.


